type MarketConfiguration @entity {
    id: ID!
    chainId: String!
    contractAddress: String!
    baseTokenAddress: String!
    baseTokenDecimals: Int!
}

type CollateralConfiguration @entity {
    id: ID!
    chainId: String!
    contractAddress: String!
    assetAddress: String!
    decimals: Int!
}

type Pool @entity {
    id: ID! # Constructed as chainId_poolAddress_underlyingTokenAddress
    chainId: String!
    creationBlockNumber: Int!
    creationTimestamp: Int!
    underlyingTokenAddress: String! # Address of the underlying token (collateral, base)
    underlyingTokenSymbol: String!
    receiptTokenAddress: String!
    receiptTokenSymbol: String!
    poolAddress: String! # Contract address of the pool (market)
    poolType: String! # collteral_only or supply_only
}

type PositionSnapshot @entity {
    id: ID!
    timestamp: Int!
    chainId: String!
    poolAddress: String!
    underlyingTokenAddress: String!
    underlyingTokenSymbol: String!
    userAddress: String!
    suppliedAmount: BigInt!
    suppliedAmountUsd: BigInt
    borrowedAmount: BigInt!
    borrowedAmountUsd: BigInt
    collateralAmount: BigInt!
    collateralAmountUsd: BigInt
}

type PoolSnapshot @entity {
    id: ID!
    timestamp: Int!
    chainId: String!
    poolAddress: String!
    underlyingTokenAddress: String!
    underlyingTokenSymbol: String!
    underlyingTokenPriceUsd: BigInt
    availableAmount: BigInt!
    availableAmountUsd: BigInt
    suppliedAmount: BigInt!
    suppliedAmountUsd: BigInt
    nonRecursiveSuppliedAmount: BigInt
    collateralAmount: BigInt
    collateralAmountUsd: BigInt
    collateralFactor: BigInt!
    supplyIndex: BigInt!
    supplyApr: BigInt!
    borrowedAmount: BigInt!
    borrowedAmountUsd: BigInt
    borrowIndex: BigInt!
    borrowApr: BigInt!
    totalFeesUsd: BigInt
    userFeesUsd: BigInt
    protocolFeesUsd: BigInt
}