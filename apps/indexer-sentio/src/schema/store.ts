
/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type { String, Int, BigInt, Float, ID, Bytes, Timestamp, Boolean } from '@sentio/sdk/store'
import { Entity, Required, One, Many, Column, ListColumn, AbstractEntity } from '@sentio/sdk/store'
import { BigDecimal } from '@sentio/bigdecimal'
import { DatabaseSchema } from '@sentio/sdk'






@Entity("Pool")
export class Pool extends AbstractEntity  {

	@Required
	@Column("ID")
	id: ID

	@Required
	@Column("String")
	chainId: String

	@Required
	@Column("Int")
	creationBlockNumber: Int

	@Required
	@Column("Int")
	creationTimestamp: Int

	@Required
	@Column("String")
	underlyingTokenAddress: String

	@Required
	@Column("String")
	underlyingTokenSymbol: String

	@Required
	@Column("String")
	receiptTokenAddress: String

	@Required
	@Column("String")
	receiptTokenSymbol: String

	@Required
	@Column("String")
	poolAddress: String

	@Required
	@Column("String")
	poolType: String
  constructor(data: Partial<Pool>) {super()}
}

@Entity("PositionSnapshot")
export class PositionSnapshot extends AbstractEntity  {

	@Required
	@Column("ID")
	id: ID

	@Required
	@Column("Int")
	timestamp: Int

	@Required
	@Column("String")
	chainId: String

	@Required
	@Column("String")
	poolAddress: String

	@Required
	@Column("String")
	underlyingTokenAddress: String

	@Required
	@Column("String")
	underlyingTokenSymbol: String

	@Required
	@Column("String")
	userAddress: String

	@Required
	@Column("Int")
	suppliedAmount: Int

	@Column("Int")
	suppliedAmountUsd?: Int

	@Required
	@Column("Int")
	borrowedAmount: Int

	@Column("Int")
	borrowedAmountUsd?: Int

	@Column("Int")
	collateralAmount?: Int

	@Column("Int")
	collateralAmountUsd?: Int
  constructor(data: Partial<PositionSnapshot>) {super()}
}

@Entity("PoolSnapshot")
export class PoolSnapshot extends AbstractEntity  {

	@Required
	@Column("ID")
	id: ID

	@Required
	@Column("Int")
	timestamp: Int

	@Required
	@Column("String")
	chainId: String

	@Required
	@Column("String")
	poolAddress: String

	@Required
	@Column("String")
	underlyingTokenAddress: String

	@Required
	@Column("String")
	underlyingTokenSymbol: String

	@Column("Int")
	underlyingTokenPriceUsd?: Int

	@Required
	@Column("Int")
	availableAmount: Int

	@Column("Int")
	availableAmountUsd?: Int

	@Required
	@Column("Int")
	suppliedAmount: Int

	@Column("Int")
	suppliedAmountUsd?: Int

	@Column("Int")
	nonRecursiveSuppliedAmount?: Int

	@Column("Int")
	collateralAmount?: Int

	@Column("Int")
	collateralAmountUsd?: Int

	@Required
	@Column("Int")
	collateralFactor: Int

	@Required
	@Column("Int")
	supplyIndex: Int

	@Required
	@Column("Int")
	supplyApr: Int

	@Required
	@Column("Int")
	borrowedAmount: Int

	@Column("Int")
	borrowedAmountUsd?: Int

	@Required
	@Column("Int")
	borrowIndex: Int

	@Required
	@Column("Int")
	borrowApr: Int

	@Column("Int")
	totalFeesUsd?: Int

	@Column("Int")
	userFeesUsd?: Int

	@Column("Int")
	protocolFeesUsd?: Int
  constructor(data: Partial<PoolSnapshot>) {super()}
}

@Entity("UserBasePosition")
export class UserBasePosition extends AbstractEntity  {

	@Required
	@Column("ID")
	id: ID

	@Required
	@Column("String")
	chainId: String

	@Required
	@Column("String")
	poolAddress: String

	@Required
	@Column("String")
	userAddress: String

	@Required
	@Column("BigInt")
	baseAmount: BigInt
  constructor(data: Partial<UserBasePosition>) {super()}
}

@Entity("UserCollateralPosition")
export class UserCollateralPosition extends AbstractEntity  {

	@Required
	@Column("ID")
	id: ID

	@Required
	@Column("String")
	chainId: String

	@Required
	@Column("String")
	poolAddress: String

	@Required
	@Column("String")
	userAddress: String

	@Required
	@Column("String")
	collateralAssetAddress: String

	@Required
	@Column("BigInt")
	collateralAmount: BigInt
  constructor(data: Partial<UserCollateralPosition>) {super()}
}


const source = `type Pool @entity {
    id: ID! # Constructed as chainId_poolAddress_underlyingTokenAddress
    chainId: String!
    creationBlockNumber: Int!
    creationTimestamp: Int!
    underlyingTokenAddress: String! # Address of the underlying token (collateral, base)
    underlyingTokenSymbol: String!
    receiptTokenAddress: String!
    receiptTokenSymbol: String!
    poolAddress: String! # Contract address of the pool (market)
    poolType: String! # collteral_only or supply_only
}

type PositionSnapshot @entity {
    id: ID!
    timestamp: Int!
    chainId: String!
    poolAddress: String!
    underlyingTokenAddress: String!
    underlyingTokenSymbol: String!
    userAddress: String!
    suppliedAmount: Int!
    suppliedAmountUsd: Int
    borrowedAmount: Int!
    borrowedAmountUsd: Int
    collateralAmount: Int
    collateralAmountUsd: Int
}

type PoolSnapshot @entity {
    id: ID!
    timestamp: Int!
    chainId: String!
    poolAddress: String!
    underlyingTokenAddress: String!
    underlyingTokenSymbol: String!
    underlyingTokenPriceUsd: Int
    availableAmount: Int!
    availableAmountUsd: Int
    suppliedAmount: Int!
    suppliedAmountUsd: Int
    nonRecursiveSuppliedAmount: Int
    collateralAmount: Int
    collateralAmountUsd: Int
    collateralFactor: Int!
    supplyIndex: Int!
    supplyApr: Int!
    borrowedAmount: Int!
    borrowedAmountUsd: Int
    borrowIndex: Int!
    borrowApr: Int!
    totalFeesUsd: Int
    userFeesUsd: Int
    protocolFeesUsd: Int
}

type UserBasePosition @entity {
    id: ID!
    chainId: String!
    poolAddress: String!
    userAddress: String!
    baseAmount: BigInt!
}

type UserCollateralPosition @entity {
    id: ID!
    chainId: String!
    poolAddress: String!
    userAddress: String!
    collateralAssetAddress: String!
    collateralAmount: BigInt!
}`
DatabaseSchema.register({
  source,
  entities: {
    "Pool": Pool,
		"PositionSnapshot": PositionSnapshot,
		"PoolSnapshot": PoolSnapshot,
		"UserBasePosition": UserBasePosition,
		"UserCollateralPosition": UserCollateralPosition
  }
})
